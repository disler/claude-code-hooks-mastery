This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.claude/
  settings.json
  settings.local.json
ai_docs/
  cc_hooks.md
  hook_data_reference.md
examples/
  comprehensive-logging.json
  developer-workflow.json
  minimal-logging.json
  security-focused.json
scripts/
  custom_notifier.py
  format_code.sh
  log_full_data.py
  log_tool_use.py
  session_summary.py
  track_file_changes.py
  validate_bash_command.py
.gitignore
CLAUDE.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/log_full_data.ts pre"
          }
        ]
      },
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/log_tool_use.ts pre"
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/validate_bash_command.ts"
          }
        ]
      },
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/track_file_changes.ts"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/log_full_data.ts post"
          }
        ]
      },
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/log_tool_use.ts post"
          }
        ]
      },
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "bash scripts/format_code.sh"
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/log_full_data.ts notification"
          },
          {
            "type": "command",
            "command": "npx ts-node scripts/custom_notifier.ts"
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/log_full_data.ts stop"
          },
          {
            "type": "command",
            "command": "npx ts-node scripts/session_summary.ts"
          }
        ]
      }
    ]
  }
}
</file>

<file path="ai_docs/cc_hooks.md">
# Claude Code Hooks Documentation

## Introduction

Claude Code hooks are user-defined shell commands that execute at various points in Claude Code's lifecycle. Hooks provide deterministic control over Claude Code's behavior, ensuring certain actions always happen rather than relying on the LLM to choose to run them.

Example use cases include:

- **Notifications**: Customize how you get notified when Claude Code is awaiting your input or permission to run something.
- **Automatic formatting**: Run `prettier` on .ts files, `gofmt` on .go files, etc. after every file edit.
- **Logging**: Track and count all executed commands for compliance or debugging.
- **Feedback**: Provide automated feedback when Claude Code produces code that does not follow your codebase conventions.
- **Custom permissions**: Block modifications to production files or sensitive directories.

By encoding these rules as hooks rather than prompting instructions, you turn suggestions into app-level code that executes every time it is expected to run.

> **⚠️ WARNING**: Hooks execute shell commands with your full user permissions without confirmation. You are responsible for ensuring your hooks are safe and secure. Anthropic is not liable for any data loss or system damage resulting from hook usage. Review Security Considerations.

## Quickstart

In this quickstart, you'll add a hook that logs the shell commands that Claude Code runs.

**Quickstart Prerequisite**: Install `jq` for JSON processing in the command line.

### Step 1: Open hooks configuration

Run the `/hooks` slash command and select the `PreToolUse` hook event.

`PreToolUse` hooks run before tool calls and can block them while providing Claude feedback on what to do differently.

### Step 2: Add a matcher

Select `+ Add new matcher…` to run your hook only on Bash tool calls.

Type `Bash` for the matcher.

### Step 3: Add the hook

Select `+ Add new hook…` and enter this command:

```bash
jq -r '"\(.tool_input.command) - \(.tool_input.description // "No description")"' >> ~/.claude/bash-command-log.txt
```

### Step 4: Save your configuration

For storage location, select `User settings` since you're logging to your home directory. This hook will then apply to all projects, not just your current project.

Then press Esc until you return to the REPL. Your hook is now registered!

### Step 5: Verify your hook

Run `/hooks` again or check `~/.claude/settings.json` to see your configuration:

```json
"hooks": {
  "PreToolUse": [
    {
      "matcher": "Bash",
      "hooks": [
        {
          "type": "command",
          "command": "jq -r '\"\\(.tool_input.command) - \\(.tool_input.description // \"No description\")\"' >> ~/.claude/bash-command-log.txt"
        }
      ]
    }
  ]
}
```

## Configuration

Claude Code hooks are configured in your settings files:

- `~/.claude/settings.json` - User settings
- `.claude/settings.json` - Project settings
- `.claude/settings.local.json` - Local project settings (not committed)
- Enterprise managed policy settings

### Structure

Hooks are organized by matchers, where each matcher can have multiple hooks:

```json
{
  "hooks": {
    "EventName": [
      {
        "matcher": "ToolPattern",
        "hooks": [
          {
            "type": "command",
            "command": "your-command-here"
          }
        ]
      }
    ]
  }
}
```

- **matcher**: Pattern to match tool names (only applicable for `PreToolUse` and `PostToolUse`)
  - Simple strings match exactly: `Write` matches only the Write tool
  - Supports regex: `Edit|Write` or `Notebook.*`
  - If omitted or empty string, hooks run for all matching events
- **hooks**: Array of commands to execute when the pattern matches
  - `type`: Currently only `"command"` is supported
  - `command`: The bash command to execute

## Hook Events

### PreToolUse

Runs after Claude creates tool parameters and before processing the tool call.

**Common matchers:**
- `Task` - Agent tasks
- `Bash` - Shell commands
- `Glob` - File pattern matching
- `Grep` - Content search
- `Read` - File reading
- `Edit`, `MultiEdit` - File editing
- `Write` - File writing
- `WebFetch`, `WebSearch` - Web operations

### PostToolUse

Runs immediately after a tool completes successfully.

Recognizes the same matcher values as PreToolUse.

### Notification

Runs when Claude Code sends notifications.

### Stop

Runs when Claude Code has finished responding.

## Hook Input

Hooks receive JSON data via stdin containing session information and event-specific data:

```typescript
{
  // Common fields
  session_id: string
  transcript_path: string  // Path to conversation JSON

  // Event-specific fields
  ...
}
```

### PreToolUse Input

The exact schema for `tool_input` depends on the tool.

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "/path/to/file.txt",
    "content": "file content"
  }
}
```

### PostToolUse Input

The exact schema for `tool_input` and `tool_response` depends on the tool.

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "/path/to/file.txt",
    "content": "file content"
  },
  "tool_response": {
    "filePath": "/path/to/file.txt",
    "success": true
  }
}
```

### Notification Input

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "message": "Task completed successfully",
  "title": "Claude Code"
}
```

### Stop Input

`stop_hook_active` is true when Claude Code is already continuing as a result of a stop hook. Check this value or process the transcript to prevent Claude Code from running indefinitely.

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "stop_hook_active": true
}
```

## Hook Output

There are two ways for hooks to return output back to Claude Code. The output communicates whether to block and any feedback that should be shown to Claude and the user.

### Simple: Exit Code

Hooks communicate status through exit codes, stdout, and stderr:

- **Exit code 0**: Success. `stdout` is shown to the user in transcript mode (CTRL-R).
- **Exit code 2**: Blocking error. `stderr` is fed back to Claude to process automatically. See per-hook-event behavior below.
- **Other exit codes**: Non-blocking error. `stderr` is shown to the user and execution continues.

#### Exit Code 2 Behavior

| Hook Event | Behavior |
|------------|----------|
| `PreToolUse` | Blocks the tool call, shows error to Claude |
| `PostToolUse` | Shows error to Claude (tool already ran) |
| `Notification` | N/A, shows stderr to user only |
| `Stop` | Blocks stoppage, shows error to Claude |

### Advanced: JSON Output

Hooks can return structured JSON in `stdout` for more sophisticated control:

#### Common JSON Fields

All hook types can include these optional fields:

```json
{
  "continue": true, // Whether Claude should continue after hook execution (default: true)
  "stopReason": "string" // Message shown when continue is false
  "suppressOutput": true, // Hide stdout from transcript mode (default: false)
}
```

If `continue` is false, Claude stops processing after the hooks run.

- For `PreToolUse`, this is different from `"decision": "block"`, which only blocks a specific tool call and provides automatic feedback to Claude.
- For `PostToolUse`, this is different from `"decision": "block"`, which provides automated feedback to Claude.
- For `Stop`, this takes precedence over any `"decision": "block"` output.
- In all cases, `"continue" = false` takes precedence over any `"decision": "block"` output.

`stopReason` accompanies `continue` with a reason shown to the user, not shown to Claude.

#### PreToolUse Decision Control

`PreToolUse` hooks can control whether a tool call proceeds.

- "approve" bypasses the permission system. `reason` is shown to the user but not to Claude.
- "block" prevents the tool call from executing. `reason` is shown to Claude.
- `undefined` leads to the existing permission flow. `reason` is ignored.

```json
{
  "decision": "approve" | "block" | undefined,
  "reason": "Explanation for decision"
}
```

#### PostToolUse Decision Control

`PostToolUse` hooks can control whether a tool call proceeds.

- "block" automatically prompts Claude with `reason`.
- `undefined` does nothing. `reason` is ignored.

```json
{
  "decision": "block" | undefined,
  "reason": "Explanation for decision"
}
```

#### Stop Decision Control

`Stop` hooks can control whether Claude must continue.

- "block" prevents Claude from stopping. You must populate `reason` for Claude to know how to proceed.
- `undefined` allows Claude to stop. `reason` is ignored.

```json
{
  "decision": "block" | undefined,
  "reason": "Must be provided when Claude is blocked from stopping"
}
```

#### JSON Output Example: Bash Command Editing

```typescript
#!/usr/bin/env npx ts-node
import * as fs from 'fs';
import * as process from 'process';

// Define validation rules as array of [regex pattern, message] tuples
const VALIDATION_RULES: [RegExp, string][] = [
    [
        /\bgrep\b(?!.*\|)/,
        "Use 'rg' (ripgrep) instead of 'grep' for better performance and features",
    ],
    [
        /\bfind\s+\S+\s+-name\b/,
        "Use 'rg --files | rg pattern' or 'rg --files -g pattern' instead of 'find -name' for better performance",
    ],
];

function validateCommand(command: string): string[] {
    const issues: string[] = [];
    for (const [pattern, message] of VALIDATION_RULES) {
        if (pattern.test(command)) {
            issues.push(message);
        }
    }
    return issues;
}

try {
    const inputData = JSON.parse(fs.readFileSync(0, 'utf8'));
    
    const toolName = inputData.tool_name || "";
    const toolInput = inputData.tool_input || {};
    const command = toolInput.command || "";
    
    if (toolName !== "Bash" || !command) {
        process.exit(1);
    }
    
    // Validate the command
    const issues = validateCommand(command);
    
    if (issues.length > 0) {
        for (const message of issues) {
            console.error(`• ${message}`);
        }
        // Exit code 2 blocks tool call and shows stderr to Claude
        process.exit(2);
    }
} catch (e: any) {
    console.error(`Error: Invalid JSON input: ${e.message}`);
    process.exit(1);
}
```

## Working with MCP Tools

Claude Code hooks work seamlessly with Model Context Protocol (MCP) tools. When MCP servers provide tools, they appear with a special naming pattern that you can match in your hooks.

### MCP Tool Naming

MCP tools follow the pattern `mcp__<server>__<tool>`, for example:

- `mcp__memory__create_entities` - Memory server's create entities tool
- `mcp__filesystem__read_file` - Filesystem server's read file tool
- `mcp__github__search_repositories` - GitHub server's search tool

### Configuring Hooks for MCP Tools

You can target specific MCP tools or entire MCP servers:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "mcp__memory__.*",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'Memory operation initiated' >> ~/mcp-operations.log"
          }
        ]
      },
      {
        "matcher": "mcp__.*__write.*",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node /home/user/scripts/validate-mcp-write.ts"
          }
        ]
      }
    ]
  }
}
```

## Examples

### Code Formatting

Automatically format code after file modifications:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "/home/user/scripts/format-code.sh"
          }
        ]
      }
    ]
  }
}
```

### Notification

Customize the notification that is sent when Claude Code requests permission or when the prompt input has become idle.

```json
{
  "hooks": {
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node ~/my_custom_notifier.ts"
          }
        ]
      }
    ]
  }
}
```

## Security Considerations

### Disclaimer

**USE AT YOUR OWN RISK**: Claude Code hooks execute arbitrary shell commands on your system automatically. By using hooks, you acknowledge that:

- You are solely responsible for the commands you configure
- Hooks can modify, delete, or access any files your user account can access
- Malicious or poorly written hooks can cause data loss or system damage
- Anthropic provides no warranty and assumes no liability for any damages resulting from hook usage
- You should thoroughly test hooks in a safe environment before production use

Always review and understand any hook commands before adding them to your configuration.

### Security Best Practices

Here are some key practices for writing more secure hooks:

1. **Validate and sanitize inputs** - Never trust input data blindly
2. **Always quote shell variables** - Use `"$VAR"` not `$VAR`
3. **Block path traversal** - Check for `..` in file paths
4. **Use absolute paths** - Specify full paths for scripts
5. **Skip sensitive files** - Avoid `.env`, `.git/`, keys, etc.

### Configuration Safety

Direct edits to hooks in settings files don't take effect immediately. Claude Code:

1. Captures a snapshot of hooks at startup
2. Uses this snapshot throughout the session
3. Warns if hooks are modified externally
4. Requires review in `/hooks` menu for changes to apply

This prevents malicious hook modifications from affecting your current session.

## Hook Execution Details

- **Timeout**: 60-second execution limit
- **Parallelization**: All matching hooks run in parallel
- **Environment**: Runs in current directory with Claude Code's environment
- **Input**: JSON via stdin
- **Output**:
  - PreToolUse/PostToolUse/Stop: Progress shown in transcript (Ctrl-R)
  - Notification: Logged to debug only (`--debug`)

## Debugging

To troubleshoot hooks:

1. Check if `/hooks` menu displays your configuration
2. Verify that your settings files are valid JSON
3. Test commands manually
4. Check exit codes
5. Review stdout and stderr format expectations
6. Ensure proper quote escaping

Progress messages appear in transcript mode (Ctrl-R) showing:

- Which hook is running
- Command being executed
- Success/failure status
- Output or error messages
</file>

<file path="ai_docs/hook_data_reference.md">
# Claude Code Hook Data Reference

## Overview

Claude Code passes JSON data to hooks via stdin. The data structure varies by hook type and tool being used. **PostToolUse** hooks have the most complete data as they include both input and response.

## Hook Data Availability

| Hook Type | Data Available | Best For |
|-----------|---------------|----------|
| **PreToolUse** | tool_name, tool_input, session_id, transcript_path | Validation, blocking, pre-processing |
| **PostToolUse** | All PreToolUse data + tool_response | Logging, analysis, post-processing |
| **Notification** | message, title, session_id, transcript_path | Custom notifications |
| **Stop** | session_id, transcript_path, stop_hook_active | Session cleanup, summaries |

## Common Fields (All Hooks)

```json
{
  "session_id": "string",          // Unique session identifier
  "transcript_path": "string"      // Path to conversation JSON file
}
```

## PreToolUse Data Structure

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "tool_name": "ToolName",
  "tool_input": {
    // Tool-specific fields (see below)
  }
}
```

## PostToolUse Data Structure

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "tool_name": "ToolName",
  "tool_input": {
    // Same as PreToolUse
  },
  "tool_response": {
    // Tool-specific response fields (see below)
  }
}
```

## Tool-Specific Data Structures

### Bash Tool

**tool_input:**
```json
{
  "command": "string",        // The bash command to execute
  "description": "string",    // Description of what the command does
  "timeout": "number"         // Optional timeout in milliseconds
}
```

**tool_response:**
```json
{
  "stdout": "string",         // Command output
  "stderr": "string",         // Error output
  "exit_code": "number",      // Exit code (0 = success)
  "timed_out": "boolean"      // Whether command timed out
}
```

### Read Tool

**tool_input:**
```json
{
  "file_path": "string",      // Absolute path to file
  "limit": "number",          // Optional line limit
  "offset": "number"          // Optional line offset
}
```

**tool_response:**
```json
{
  "content": "string",        // File content
  "lines_read": "number",     // Number of lines read
  "total_lines": "number",    // Total lines in file
  "truncated": "boolean"      // Whether content was truncated
}
```

### Write Tool

**tool_input:**
```json
{
  "file_path": "string",      // Absolute path to file
  "content": "string"         // Content to write
}
```

**tool_response:**
```json
{
  "success": "boolean",       // Whether write succeeded
  "file_path": "string",      // Path to written file
  "bytes_written": "number"   // Number of bytes written
}
```

### Edit Tool

**tool_input:**
```json
{
  "file_path": "string",      // Absolute path to file
  "old_string": "string",     // Text to replace
  "new_string": "string",     // Replacement text
  "replace_all": "boolean"    // Replace all occurrences
}
```

**tool_response:**
```json
{
  "success": "boolean",       // Whether edit succeeded
  "replacements": "number",   // Number of replacements made
  "file_path": "string"       // Path to edited file
}
```

### MultiEdit Tool

**tool_input:**
```json
{
  "file_path": "string",      // Absolute path to file
  "edits": [                  // Array of edit operations
    {
      "old_string": "string",
      "new_string": "string",
      "replace_all": "boolean"
    }
  ]
}
```

**tool_response:**
```json
{
  "success": "boolean",       // Whether all edits succeeded
  "edits_applied": "number",  // Number of edits applied
  "file_path": "string"       // Path to edited file
}
```

### Glob Tool

**tool_input:**
```json
{
  "pattern": "string",        // Glob pattern (e.g., "**/*.js")
  "path": "string"            // Optional directory path
}
```

**tool_response:**
```json
{
  "matches": ["string"],      // Array of matching file paths
  "match_count": "number"     // Number of matches found
}
```

### Grep Tool

**tool_input:**
```json
{
  "pattern": "string",        // Regular expression pattern
  "path": "string",           // Directory to search
  "include": "string"         // File pattern to include
}
```

**tool_response:**
```json
{
  "matches": [                // Array of matches
    {
      "file": "string",
      "line": "number",
      "content": "string"
    }
  ],
  "file_count": "number",     // Number of files with matches
  "match_count": "number"     // Total number of matches
}
```

### Task Tool

**tool_input:**
```json
{
  "description": "string",    // Task description
  "prompt": "string"          // Detailed task prompt
}
```

**tool_response:**
```json
{
  "task_id": "string",        // Unique task identifier
  "status": "string",         // Task status
  "result": "string"          // Task result/output
}
```

### TodoWrite Tool

**tool_input:**
```json
{
  "todos": [                  // Array of todo items
    {
      "id": "string",
      "content": "string",
      "status": "string",     // "pending", "in_progress", "completed"
      "priority": "string"    // "high", "medium", "low"
    }
  ]
}
```

**tool_response:**
```json
{
  "success": "boolean",       // Whether update succeeded
  "todo_count": "number"      // Number of todos in list
}
```

### WebFetch Tool

**tool_input:**
```json
{
  "url": "string",            // URL to fetch
  "prompt": "string"          // Prompt for content analysis
}
```

**tool_response:**
```json
{
  "content": "string",        // Fetched/analyzed content
  "url": "string",            // Actual URL fetched
  "status_code": "number"     // HTTP status code
}
```

### WebSearch Tool

**tool_input:**
```json
{
  "query": "string",          // Search query
  "allowed_domains": ["string"], // Optional domain filter
  "blocked_domains": ["string"]  // Optional domain blocklist
}
```

**tool_response:**
```json
{
  "results": [                // Array of search results
    {
      "title": "string",
      "url": "string",
      "snippet": "string"
    }
  ],
  "result_count": "number"    // Number of results
}
```

### NotebookRead Tool

**tool_input:**
```json
{
  "notebook_path": "string",  // Path to .ipynb file
  "cell_id": "string"         // Optional specific cell ID
}
```

**tool_response:**
```json
{
  "cells": [                  // Array of notebook cells
    {
      "id": "string",
      "type": "string",       // "code" or "markdown"
      "source": "string",
      "outputs": []           // Cell outputs
    }
  ],
  "cell_count": "number"      // Number of cells
}
```

### NotebookEdit Tool

**tool_input:**
```json
{
  "notebook_path": "string",  // Path to .ipynb file
  "cell_id": "string",        // Cell to edit
  "new_source": "string",     // New cell content
  "cell_type": "string",      // "code" or "markdown"
  "edit_mode": "string"       // "replace", "insert", "delete"
}
```

**tool_response:**
```json
{
  "success": "boolean",       // Whether edit succeeded
  "cell_id": "string",        // ID of edited cell
  "notebook_path": "string"   // Path to notebook
}
```

### MCP Tool Pattern

MCP tools follow the naming pattern `mcp__<server>__<tool>`. Their data structures vary by the specific MCP server and tool.

**Example tool_input:**
```json
{
  // Varies by MCP tool
  "custom_field": "value"
}
```

**Example tool_response:**
```json
{
  // Varies by MCP tool
  "result": "value"
}
```

## Notification Hook Data

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "message": "string",        // Notification message
  "title": "string"           // Notification title (usually "Claude Code")
}
```

## Stop Hook Data

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "stop_hook_active": "boolean"  // true if already in stop hook (prevent loops)
}
```

## Important Notes

1. **Data Availability**: PostToolUse hooks have the most complete data (input + response)
2. **Field Variability**: Not all fields are always present; use defensive coding
3. **MCP Tools**: Data structures vary significantly for MCP tools
4. **Error States**: tool_response may contain error information instead of success data
5. **Async Operations**: Some tools may have incomplete responses in PostToolUse

## Debugging Tips

To see actual data structures:
1. Use the `log_full_data.ts` script to capture all hook data
2. Check `logs/tool-data-structures.jsonl` for raw data
3. Review `logs/tool-data-*.json` for pretty-printed examples
4. Use `jq` to explore the JSON structure interactively

## Example: Exploring Hook Data

```bash
# See all tool names used
cat logs/tool-data-structures.jsonl | jq -r '.parsed_data.tool_name' | sort | uniq

# See all fields for a specific tool
cat logs/tool-data-structures.jsonl | jq 'select(.parsed_data.tool_name == "Bash")'

# Extract all bash commands
cat logs/tool-data-structures.jsonl | jq -r 'select(.parsed_data.tool_name == "Bash") | .parsed_data.tool_input.command'
```
</file>

<file path="examples/comprehensive-logging.json">
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Task",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[TASK_START] \\(.session_id) | \\(.tool_input | tostring)\"' >> logs/all-tools.jsonl"
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"bash_pre\", session: .session_id, command: .tool_input.command, description: .tool_input.description}' >> logs/bash-audit.jsonl"
          }
        ]
      },
      {
        "matcher": "Glob|Grep",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"search_pre\", session: .session_id, tool: .tool_name, pattern: (.tool_input.pattern // .tool_input.query)}' >> logs/search-audit.jsonl"
          }
        ]
      },
      {
        "matcher": "Read|NotebookRead",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"read_pre\", session: .session_id, file: (.tool_input.file_path // .tool_input.notebook_path)}' >> logs/file-access.jsonl"
          }
        ]
      },
      {
        "matcher": "Write|Edit|MultiEdit|NotebookEdit",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"write_pre\", session: .session_id, tool: .tool_name, file: (.tool_input.file_path // .tool_input.notebook_path)}' >> logs/file-modifications.jsonl"
          }
        ]
      },
      {
        "matcher": "WebFetch|WebSearch",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"web_pre\", session: .session_id, tool: .tool_name, url: .tool_input.url, query: .tool_input.query}' >> logs/web-access.jsonl"
          }
        ]
      },
      {
        "matcher": "TodoWrite",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"todo_update\", session: .session_id, todos: .tool_input.todos}' >> logs/todo-tracking.jsonl"
          }
        ]
      },
      {
        "matcher": "mcp__.*",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"mcp_pre\", session: .session_id, tool: .tool_name, input: .tool_input}' >> logs/mcp-tools.jsonl"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"tool_post\", session: .session_id, tool: .tool_name, success: (.tool_response.success // true), response: .tool_response}' >> logs/all-tools-results.jsonl"
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r 'if (.tool_response.exit_code // 0) != 0 then {timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"bash_error\", session: .session_id, command: .tool_input.command, exit_code: .tool_response.exit_code, stderr: .tool_response.stderr} else empty end' >> logs/bash-errors.jsonl"
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"notification\", session: .session_id, title: .title, message: .message}' >> logs/notifications.jsonl"
          },
          {
            "type": "command",
            "command": "echo \"$(date '+%Y-%m-%d %H:%M:%S') | $(jq -r '.message')\" | tee -a logs/notification-history.txt"
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '{timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), event: \"session_stop\", session: .session_id, transcript: .transcript_path, stop_hook_active: .stop_hook_active}' >> logs/sessions.jsonl"
          },
          {
            "type": "command",
            "command": "echo \"\\n=== Session Summary ===\\nSession ID: $(jq -r '.session_id')\\nTranscript: $(jq -r '.transcript_path')\\nTime: $(date)\\n=====================\\n\" >> logs/session-summaries.txt"
          }
        ]
      }
    ]
  }
}
</file>

<file path="examples/developer-workflow.json">
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/check_branch.ts"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/auto_format.ts"
          },
          {
            "type": "command",
            "command": "npx ts-node scripts/run_linters.ts"
          },
          {
            "type": "command",
            "command": "npx ts-node scripts/update_tests.ts"
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r 'select(.tool_input.command | test(\"npm|yarn|pnpm\")) | {timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), package_command: .tool_input.command}' >> logs/package-commands.jsonl"
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/slack_notifier.ts"
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/commit_reminder.ts"
          },
          {
            "type": "command",
            "command": "npx ts-node scripts/test_coverage_report.ts"
          }
        ]
      }
    ]
  }
}
</file>

<file path="examples/minimal-logging.json">
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "echo \"[$(date)] Tool: $TOOL_NAME\" >> simple.log || true"
          }
        ]
      }
    ]
  }
}
</file>

<file path="examples/security-focused.json">
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/security_validator.ts"
          }
        ]
      },
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/file_security_check.ts"
          }
        ]
      },
      {
        "matcher": "WebFetch|WebSearch",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/url_validator.ts"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r 'if (.tool_response.exit_code // 0) != 0 then {timestamp: now | strftime(\"%Y-%m-%dT%H:%M:%SZ\"), alert: \"COMMAND_FAILED\", command: .tool_input.command, exit_code: .tool_response.exit_code, stderr: .tool_response.stderr} else empty end' >> logs/security-alerts.jsonl"
          }
        ]
      },
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "npx ts-node scripts/audit_logger.ts"
          }
        ]
      }
    ]
  }
}
</file>

<file path="scripts/custom_notifier.ts">
#!/usr/bin/env npx ts-node
/**
 * Custom notification handler for Claude Code.
 * Logs notifications and can be extended to send to various notification systems.
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

function main(): void {
    let hookInput: any;
    try {
        // Read notification data from stdin
        const input = fs.readFileSync(0, 'utf8');
        hookInput = JSON.parse(input);
    } catch {
        process.exit(0);
    }
    
    // Extract notification details
    const message = hookInput.message || "";
    const title = hookInput.title || "Claude Code";
    const sessionId = hookInput.session_id || "unknown";
    
    // Ensure logs directory exists
    const logDir = "logs";
    if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
    }
    
    // Log notification to file
    const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
    const logEntry = `[${timestamp}] [${sessionId}] ${title}: ${message}\n`;
    
    fs.appendFileSync(path.join(logDir, "notifications-detailed.log"), logEntry);
    
    // Platform-specific notification (optional)
    // You can uncomment and customize these based on your platform:
    
    // macOS notification using osascript
    if (process.platform === "darwin" && fs.existsSync("/usr/bin/osascript")) {
        // Escape quotes for AppleScript
        const escapedMessage = message.replace(/"/g, '\\"');
        const escapedTitle = title.replace(/"/g, '\\"');
        // Uncomment to enable desktop notifications:
        // execSync(`osascript -e 'display notification "${escapedMessage}" with title "${escapedTitle}"'`);
    }
    
    // Linux notification using notify-send
    else if (process.platform === "linux" && fs.existsSync("/usr/bin/notify-send")) {
        // Uncomment to enable desktop notifications:
        // execSync(`notify-send "${title}" "${message}"`);
    }
    
    // Windows notification (requires node-notifier or similar)
    else if (process.platform === "win32") {
        // Uncomment and install node-notifier to enable:
        // const notifier = require('node-notifier');
        // notifier.notify({ title, message, time: 10000 });
    }
    
    process.exit(0);
}

if (require.main === module) {
    main();
}
</file>

<file path="scripts/format_code.ts">
#!/usr/bin/env npx ts-node
/**
 * Auto-format code based on file extension.
 * This script runs after file modifications to ensure consistent formatting.
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

function commandExists(command: string): boolean {
    try {
        execSync(`command -v ${command}`, { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

function logMessage(message: string): void {
    const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
    const logEntry = `[${timestamp}] ${message}\n`;
    
    if (!fs.existsSync('logs')) {
        fs.mkdirSync('logs', { recursive: true });
    }
    
    fs.appendFileSync('logs/formatting.log', logEntry);
}

function runCommand(command: string, filePath: string, commandName: string): void {
    try {
        logMessage(`  Running ${commandName} on ${filePath}`);
        execSync(command, { stdio: 'ignore' });
    } catch (error: any) {
        const errorLog = `Error running ${commandName}: ${error.message}\n`;
        if (!fs.existsSync('logs')) {
            fs.mkdirSync('logs', { recursive: true });
        }
        fs.appendFileSync('logs/formatting-errors.log', errorLog);
    }
}

function main(): void {
    let hookInput: any;
    try {
        const input = fs.readFileSync(0, 'utf8');
        hookInput = JSON.parse(input);
    } catch {
        process.exit(0);
    }
    
    // Extract file path and tool name
    const filePath = hookInput.tool_input?.file_path || hookInput.tool_input?.notebook_path || "";
    const toolName = hookInput.tool_name || "";
    
    // Only process file modifications
    if (!["Write", "Edit", "MultiEdit"].includes(toolName)) {
        process.exit(0);
    }
    
    // Skip if no file path
    if (!filePath || filePath === "null") {
        process.exit(0);
    }
    
    logMessage(`Checking format for: ${filePath}`);
    
    // Get file extension and basename
    const ext = path.extname(filePath).slice(1); // Remove the dot
    const basename = path.basename(filePath);
    
    // Skip formatting for certain files
    const skipFiles = ['.gitignore', '.env', '.md', '.txt', '.log', '.json', '.yml', '.yaml'];
    if (skipFiles.some(skip => basename.includes(skip) || basename.endsWith(skip.slice(1)))) {
        logMessage(`  Skipping format for ${basename}`);
        process.exit(0);
    }
    
    // Format based on extension
    switch (ext) {
        case 'js':
        case 'jsx':
        case 'ts':
        case 'tsx':
            // JavaScript/TypeScript formatting
            if (commandExists('prettier')) {
                runCommand(`prettier --write "${filePath}"`, filePath, 'prettier');
            } else if (commandExists('eslint')) {
                runCommand(`eslint --fix "${filePath}"`, filePath, 'eslint');
            }
            break;
            
        case 'go':
            // Go formatting
            if (commandExists('gofmt')) {
                runCommand(`gofmt -w "${filePath}"`, filePath, 'gofmt');
            }
            
            if (commandExists('goimports')) {
                runCommand(`goimports -w "${filePath}"`, filePath, 'goimports');
            }
            break;
            
        case 'rs':
            // Rust formatting
            if (commandExists('rustfmt')) {
                runCommand(`rustfmt "${filePath}"`, filePath, 'rustfmt');
            }
            break;
            
        case 'sh':
        case 'bash':
            // Shell script formatting
            if (commandExists('shfmt')) {
                runCommand(`shfmt -w "${filePath}"`, filePath, 'shfmt');
            }
            break;
            
        default:
            logMessage(`  No formatter configured for .${ext} files`);
            break;
    }
    
    // Always exit successfully to not block operations
    process.exit(0);
}

if (require.main === module) {
    main();
}
</file>

<file path="scripts/log_full_data.ts">
#!/usr/bin/env npx ts-node
/**
 * Log complete tool data structures for debugging and exploration.
 * Shows all available fields in hook inputs.
 */

import * as fs from 'fs';
import * as path from 'path';

function main(): void {
    // Ensure logs directory exists
    const logDir = "logs";
    if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
    }
    
    // Read raw input
    const rawInput = fs.readFileSync(0, 'utf8');
    
    try {
        // Parse JSON
        const hookInput = JSON.parse(rawInput);
        
        // Determine hook type from command line args
        const hookType = process.argv.length > 2 ? process.argv[2] : "unknown";
        
        // Create detailed log entry
        const logEntry = {
            timestamp: new Date().toISOString(),
            hook_type: hookType,
            raw_input_length: rawInput.length,
            parsed_data: hookInput
        };
        
        // Write to detailed log file
        const logFile = path.join(logDir, "tool-data-structures.jsonl");
        fs.appendFileSync(logFile, JSON.stringify(logEntry, null, 2) + "\n");
        
        // Also write a pretty-printed version for easier reading
        const prettyFile = path.join(logDir, `tool-data-${hookType}.json`);
        fs.writeFileSync(prettyFile, JSON.stringify(hookInput, null, 2));
        
        // Create a human-readable summary
        const summaryFile = path.join(logDir, "tool-data-summary.log");
        const summaryLines = [
            `\n${'='.repeat(60)}`,
            `Timestamp: ${new Date()}`,
            `Hook Type: ${hookType}`,
            `Tool Name: ${hookInput.tool_name || 'N/A'}`,
            `Session ID: ${hookInput.session_id || 'N/A'}`,
            `Available Keys: ${Object.keys(hookInput).join(', ')}`
        ];
        
        // Show tool_input structure
        if (hookInput.tool_input) {
            summaryLines.push(`Tool Input Keys: ${Object.keys(hookInput.tool_input).join(', ')}`);
        }
        
        // Show tool_response structure (for post hooks)
        if (hookInput.tool_response) {
            summaryLines.push(`Tool Response Keys: ${Object.keys(hookInput.tool_response).join(', ')}`);
        }
        
        summaryLines.push('='.repeat(60));
        fs.appendFileSync(summaryFile, summaryLines.join('\n') + '\n');
        
    } catch (e: any) {
        // Log error
        const errorEntry = {
            timestamp: new Date().toISOString(),
            error: e.message,
            raw_input: rawInput.slice(0, 1000)  // First 1000 chars
        };
        
        const errorFile = path.join(logDir, "tool-data-errors.jsonl");
        fs.appendFileSync(errorFile, JSON.stringify(errorEntry) + "\n");
    }
    
    // Always exit successfully
    process.exit(0);
}

if (require.main === module) {
    main();
}
</file>

<file path="scripts/log_tool_use.ts">
#!/usr/bin/env npx ts-node
/**
 * Universal tool use logger for Claude Code hooks.
 * Logs all tool usage to a structured JSON format.
 */

import * as fs from 'fs';
import * as path from 'path';

function main(): void {
    // Ensure logs directory exists
    const logDir = "logs";
    if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
    }
    
    // Read hook input from stdin
    let hookInput: any;
    try {
        const input = fs.readFileSync(0, 'utf8');
        hookInput = JSON.parse(input);
    } catch (e: any) {
        // Log error and exit gracefully
        const errorLog = path.join(logDir, "hook-errors.log");
        fs.appendFileSync(errorLog, `[${new Date().toISOString()}] JSON decode error in log_tool_use.ts: ${e.message}\n`);
        process.exit(0);
    }
    
    // Determine if this is pre or post hook
    const hookType = process.argv.length > 2 ? process.argv[2] : "unknown";
    
    // Create log entry
    const logEntry: any = {
        timestamp: new Date().toISOString(),
        hook_type: hookType,
        session_id: hookInput.session_id,
        tool_name: hookInput.tool_name,
        transcript_path: hookInput.transcript_path
    };
    
    // Add tool-specific information
    if (hookType === "pre") {
        logEntry.tool_input = hookInput.tool_input || {};
    } else if (hookType === "post") {
        logEntry.tool_input = hookInput.tool_input || {};
        logEntry.tool_response = hookInput.tool_response || {};
    }
    
    // Write to log file
    const logFile = path.join(logDir, "tool-usage.jsonl");
    fs.appendFileSync(logFile, JSON.stringify(logEntry) + "\n");
    
    // Success - no output means continue
    process.exit(0);
}

if (require.main === module) {
    main();
}
</file>

<file path="scripts/session_summary.ts">
#!/usr/bin/env npx ts-node
/**
 * Generate session summary when Claude Code stops.
 * Can optionally block stop if tasks are incomplete.
 */

import * as fs from 'fs';
import * as path from 'path';

interface SessionStats {
    total_tools: number;
    tool_counts: { [key: string]: number };
    file_reads: string[];
    file_writes: string[];
    bash_commands: string[];
    errors: number;
}

function analyzeSession(sessionId: string): SessionStats {
    const stats: SessionStats = {
        total_tools: 0,
        tool_counts: {},
        file_reads: [],
        file_writes: [],
        bash_commands: [],
        errors: 0
    };
    
    // Read tool usage log if it exists
    const toolLog = "logs/tool-usage.jsonl";
    if (fs.existsSync(toolLog)) {
        const lines = fs.readFileSync(toolLog, 'utf8').split('\n').filter(line => line.trim());
        for (const line of lines) {
            try {
                const entry = JSON.parse(line);
                if (entry.session_id === sessionId) {
                    stats.total_tools += 1;
                    const toolName = entry.tool_name || "unknown";
                    stats.tool_counts[toolName] = (stats.tool_counts[toolName] || 0) + 1;
                    
                    // Track specific operations
                    if (toolName === "Read") {
                        const filePath = entry.tool_input?.file_path;
                        if (filePath) {
                            stats.file_reads.push(filePath);
                        }
                    } else if (["Write", "Edit", "MultiEdit"].includes(toolName)) {
                        const filePath = entry.tool_input?.file_path;
                        if (filePath) {
                            stats.file_writes.push(filePath);
                        }
                    } else if (toolName === "Bash") {
                        const command = entry.tool_input?.command;
                        if (command) {
                            stats.bash_commands.push(command);
                        }
                    }
                    
                    // Check for errors in post hooks
                    if (entry.hook_type === "post") {
                        const response = entry.tool_response || {};
                        if (!response.success || (response.exit_code && response.exit_code !== 0)) {
                            stats.errors += 1;
                        }
                    }
                }
            } catch {
                // Skip invalid lines
            }
        }
    }
    
    return stats;
}

function checkIncompleteTodos(sessionId: string): any[] {
    // This is a placeholder - in a real implementation, you might
    // read the TodoRead output from the transcript
    return [];
}

function main(): void {
    let hookInput: any;
    try {
        const input = fs.readFileSync(0, 'utf8');
        hookInput = JSON.parse(input);
    } catch {
        process.exit(0);
    }
    
    const sessionId = hookInput.session_id || "unknown";
    const transcriptPath = hookInput.transcript_path || "";
    const stopHookActive = hookInput.stop_hook_active || false;
    
    // Don't create infinite loops
    if (stopHookActive) {
        process.exit(0);
    }
    
    // Analyze the session
    const stats = analyzeSession(sessionId);
    
    // Generate summary
    let summary = `
=== Session Summary ===
Session ID: ${sessionId}
End Time: ${new Date().toLocaleString()}
Total Tool Calls: ${stats.total_tools}
Tool Usage:
`;
    
    // Sort tool counts by frequency
    const sortedTools = Object.entries(stats.tool_counts)
        .sort(([,a], [,b]) => b - a);
    
    for (const [tool, count] of sortedTools) {
        summary += `  - ${tool}: ${count}\n`;
    }
    
    summary += `
Files Read: ${stats.file_reads.length}
Files Modified: ${stats.file_writes.length}
Bash Commands: ${stats.bash_commands.length}
Errors Encountered: ${stats.errors}
Transcript: ${transcriptPath}
=====================
`;
    
    // Write summary to log
    fs.appendFileSync("logs/session-summaries.txt", summary);
    
    // Also create a JSON summary for programmatic access
    const jsonSummary = {
        session_id: sessionId,
        end_time: new Date().toISOString(),
        stats: {
            total_tools: stats.total_tools,
            tool_counts: stats.tool_counts,
            files_read: stats.file_reads.length,
            files_modified: stats.file_writes.length,
            bash_commands: stats.bash_commands.length,
            errors: stats.errors
        },
        transcript_path: transcriptPath
    };
    
    fs.appendFileSync("logs/session-summaries.jsonl", JSON.stringify(jsonSummary) + "\n");
    
    // Example: Block stop if there are errors (commented out)
    // if (stats.errors > 0) {
    //     const output = {
    //         decision: "block",
    //         reason: `Session had ${stats.errors} errors. Please review before ending.`
    //     };
    //     console.log(JSON.stringify(output));
    //     process.exit(0);
    // }
    
    // Example: Check for incomplete todos (commented out)
    // const incomplete = checkIncompleteTodos(sessionId);
    // if (incomplete.length > 0) {
    //     const output = {
    //         decision: "block",
    //         reason: `You have ${incomplete.length} incomplete todos. Complete them?`
    //     };
    //     console.log(JSON.stringify(output));
    //     process.exit(0);
    // }
    
    process.exit(0);
}

if (require.main === module) {
    main();
}
</file>

<file path="scripts/track_file_changes.ts">
#!/usr/bin/env npx ts-node
/**
 * Track file changes for audit purposes.
 * Creates a detailed log of all file modifications.
 */

import * as fs from 'fs';
import * as path from 'path';

interface FileInfo {
    exists: boolean;
    size?: number;
    mode?: string;
    is_dir?: boolean;
    is_file?: boolean;
}

function getFileInfo(filePath: string): FileInfo {
    try {
        if (fs.existsSync(filePath)) {
            const stats = fs.statSync(filePath);
            return {
                exists: true,
                size: stats.size,
                mode: '0' + (stats.mode & parseInt('777', 8)).toString(8),
                is_dir: stats.isDirectory(),
                is_file: stats.isFile(),
            };
        }
    } catch {
        // Ignore errors
    }
    return { exists: false };
}

function main(): void {
    let hookInput: any;
    try {
        const input = fs.readFileSync(0, 'utf8');
        hookInput = JSON.parse(input);
    } catch {
        process.exit(0);
    }
    
    const toolName = hookInput.tool_name || "";
    if (!["Write", "Edit", "MultiEdit", "NotebookEdit"].includes(toolName)) {
        process.exit(0);
    }
    
    // Ensure logs directory exists
    const logDir = "logs";
    if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
    }
    
    // Extract file path
    const toolInput = hookInput.tool_input || {};
    const filePath = toolInput.file_path || toolInput.notebook_path || "unknown";
    
    // Create detailed log entry
    const logEntry: any = {
        timestamp: new Date().toISOString(),
        tool: toolName,
        file: filePath,
        session_id: hookInput.session_id,
        file_info: getFileInfo(filePath),
        user: process.env.USER || "unknown",
        cwd: process.cwd(),
    };
    
    // Add operation-specific details
    if (toolName === "Write") {
        logEntry.operation = "create_or_overwrite";
        logEntry.content_length = (toolInput.content || "").length;
    } else if (toolName === "Edit") {
        logEntry.operation = "edit";
        logEntry.old_string_length = (toolInput.old_string || "").length;
        logEntry.new_string_length = (toolInput.new_string || "").length;
        logEntry.replace_all = toolInput.replace_all || false;
    } else if (toolName === "MultiEdit") {
        logEntry.operation = "multi_edit";
        logEntry.edit_count = (toolInput.edits || []).length;
    }
    
    // Write to audit log
    const auditFile = path.join(logDir, "file-changes-audit.jsonl");
    fs.appendFileSync(auditFile, JSON.stringify(logEntry) + "\n");
    
    // Also write a simple summary to a human-readable log
    const summary = `[${logEntry.timestamp}] ${toolName}: ${filePath} by ${logEntry.user}`;
    const summaryFile = path.join(logDir, "file-changes-summary.log");
    fs.appendFileSync(summaryFile, summary + "\n");
    
    process.exit(0);
}

if (require.main === module) {
    main();
}
</file>

<file path="scripts/validate_bash_command.ts">
#!/usr/bin/env npx ts-node
/**
 * Validate bash commands and provide feedback to Claude Code.
 * Can block dangerous commands and suggest improvements.
 */

import * as fs from 'fs';

// Define validation rules as [regex pattern, message, is_dangerous] tuples
const VALIDATION_RULES: [RegExp, string, boolean][] = [
    // Performance suggestions
    [/\bgrep\b(?!.*\|)/, "Use 'rg' (ripgrep) instead of 'grep' for better performance and features", false],
    [/\bfind\s+\S+\s+-name\b/, "Use 'rg --files | rg pattern' or 'rg --files -g pattern' instead of 'find -name' for better performance", false],
    [/\bcat\s+.*\|\s*grep\b/, "Use 'rg pattern file' instead of 'cat file | grep pattern'", false],
    
    // Security warnings
    [/\brm\s+-rf\s+\/(?:\s|$)/, "DANGER: Attempting to remove root directory!", true],
    [/\brm\s+-rf\s+~(?:\/|$|\s)/, "DANGER: Attempting to remove home directory!", true],
    [/\bdd\s+.*of=\/dev\/[sh]d[a-z](?:\d|$)/, "DANGER: Direct disk write operation detected!", true],
    [/>\s*\/dev\/[sh]d[a-z]/, "DANGER: Attempting to write directly to disk device!", true],
    
    // Insecure practices
    [/\bcurl\s+.*\s+-k\b/, "Security Warning: -k flag disables SSL certificate verification", false],
    [/\bwget\s+.*--no-check-certificate\b/, "Security Warning: --no-check-certificate disables SSL verification", false],
    [/\bchmod\s+777\b/, "Security Warning: chmod 777 gives full permissions to everyone", false],
    [/\bsudo\s+chmod\s+-R\s+777\b/, "DANGER: Recursive chmod 777 is extremely insecure!", true],
    
    // Best practices
    [/cd\s+&&\s+ls/, "Consider using 'ls <directory>' instead of 'cd && ls'", false],
    [/\|\s*wc\s+-l\b/, "Consider using 'rg -c' for counting matches in files", false],
];

function validateCommand(command: string): [string[], boolean] {
    const issues: string[] = [];
    let shouldBlock = false;
    
    for (const [pattern, message, isDangerous] of VALIDATION_RULES) {
        if (pattern.test(command)) {
            issues.push(message);
            if (isDangerous) {
                shouldBlock = true;
            }
        }
    }
    
    return [issues, shouldBlock];
}

function main(): void {
    let inputData: any;
    try {
        const input = fs.readFileSync(0, 'utf8');
        inputData = JSON.parse(input);
    } catch {
        // If JSON parsing fails, exit silently
        process.exit(0);
    }
    
    // Check if this is a Bash tool call
    const toolName = inputData.tool_name || "";
    if (toolName !== "Bash") {
        process.exit(0);
    }
    
    // Get the command
    const command = inputData.tool_input?.command || "";
    if (!command) {
        process.exit(0);
    }
    
    // Validate the command
    const [issues, shouldBlock] = validateCommand(command);
    
    if (issues.length > 0) {
        // Output issues to stderr (will be shown to Claude)
        for (const message of issues) {
            console.error(`• ${message}`);
        }
        
        // Exit code 2 blocks the command
        if (shouldBlock) {
            process.exit(2);
        }
    }
    
    // Exit code 0 allows the command to proceed
    process.exit(0);
}

if (require.main === module) {
    main();
}
</file>

<file path=".gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.pytest_cache/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/

# TypeScript / Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*
.npm
.eslintcache
.tsbuildinfo
*.tsbuildinfo
.next/
out/
dist/
.cache/
.parcel-cache/
.docusaurus
.serverless/
.fusebox/
.dynamodb/
.tern-port
.vscode-test
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace
.DS_Store

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs/
*.log

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
</file>

<file path=".claude/settings.json">
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[\" + (now | strftime(\"%Y-%m-%d %H:%M:%S\")) + \"] Bash command: \" + .tool_input.command' >> logs/bash-commands.log"
          }
        ]
      },
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[\" + (now | strftime(\"%Y-%m-%d %H:%M:%S\")) + \"] File modification: \" + (.tool_input.file_path // .tool_input.filePath // \"unknown\")' >> logs/file-modifications.log"
          }
        ]
      },
      {
        "matcher": "Read",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[\" + (now | strftime(\"%Y-%m-%d %H:%M:%S\")) + \"] File read: \" + .tool_input.file_path' >> logs/file-reads.log"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[\" + (now | strftime(\"%Y-%m-%d %H:%M:%S\")) + \"] Bash completed: exit_code=\" + (.tool_response.exit_code // 0 | tostring)' >> logs/bash-results.log"
          }
        ]
      },
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[\" + (now | strftime(\"%Y-%m-%d %H:%M:%S\")) + \"] File operation completed: \" + (.tool_response.success // false | tostring)' >> logs/file-results.log"
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[\" + (now | strftime(\"%Y-%m-%d %H:%M:%S\")) + \"] Notification: \" + .message' >> logs/notifications.log"
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '\"[\" + (now | strftime(\"%Y-%m-%d %H:%M:%S\")) + \"] Session ended: \" + .session_id' >> logs/sessions.log"
          }
        ]
      }
    ]
  }
}
</file>

<file path="CLAUDE.md">
# Claude Code Hooks Project Instructions

## Project Overview

This is a Claude Code hooks demonstration project that showcases comprehensive logging, security validation, and workflow automation through hooks.

## Active Hooks

You currently have hooks configured in:
- `.claude/settings.json` - Basic logging with jq commands
- `.claude/settings.local.json` - Advanced Python scripts for validation and logging

These hooks are actively:
1. Logging all your commands to `logs/`
2. Validating bash commands for safety
3. Tracking file modifications
4. Creating session summaries

## Important Behaviors

### Command Validation
- Commands like `rm -rf /` will be BLOCKED by `validate_bash_command.ts`
- You'll see validation errors that explain why commands are dangerous
- The hook uses exit code 2 to block execution

### Automatic Logging
- Every tool use is logged to multiple files
- Check `logs/tool-data-summary.log` for human-readable summaries
- Full JSON data is in `logs/tool-data-structures.jsonl`

### File Operations
- All file reads/writes are tracked in audit logs
- Code formatting runs automatically after file modifications (if formatters are installed)
- File changes include metadata like user, timestamp, and operation type

## Working with This Project

### Testing Hooks
To test if hooks are working:
```bash
echo "test" > test.txt  # Will trigger Write hooks
cat test.txt           # Will trigger Read hooks
rm test.txt           # Will trigger Bash hooks
```

### Viewing Logs
Most useful log commands:
```bash
# See recent tool usage
tail -f logs/tool-data-summary.log

# Check bash command history
cat logs/bash-commands.log

# Find errors
grep -i error logs/*.log

# Analyze tool usage
cat logs/tool-usage.jsonl | jq -r .tool_name | sort | uniq -c
```

### Modifying Hooks
1. Edit `.claude/settings.local.json` for changes
2. Restart Claude Code (hooks are cached at startup)
3. Test your changes

### Debugging Hook Issues
If hooks aren't working:
1. Check script permissions: `ls -la scripts/`
2. Test scripts manually: `echo '{}' | npx ts-node scripts/log_tool_use.ts pre`
3. Check for JSON errors: `jq . .claude/settings*.json`

## Hook Data Available

When hooks run, they receive:
- `session_id` - Your current session ID
- `transcript_path` - Path to conversation log
- `tool_name` - Name of the tool being used
- `tool_input` - Input parameters (PreToolUse)
- `tool_response` - Results (PostToolUse only)

## Security Notes

- Hooks run with YOUR permissions
- Be careful with hook scripts that modify files
- Validation hooks can prevent dangerous operations
- All logs may contain sensitive information

## Performance Considerations

Current hooks add minimal overhead, but:
- Many hooks can slow operations
- File I/O in hooks affects performance
- Consider disabling verbose logging for large operations

## Extending the System

To add new functionality:
1. Create new scripts in `scripts/`
2. Add hook configuration to settings
3. Test thoroughly before production use
4. Document your additions

## Quick Reference

**Check active hooks:**
```
/hooks
```

**Temporarily disable hooks:**
```bash
mv .claude/settings.local.json .claude/settings.local.json.disabled
# Restart Claude Code
```

**View session summary:**
```bash
tail logs/session-summaries.txt
```

## Troubleshooting

**If you see "command blocked by hook":**
- Check the error message for details
- The command may be dangerous
- Review `scripts/validate_bash_command.ts` for rules

**If logs aren't being created:**
- Ensure `logs/` directory exists
- Check script permissions
- Verify `jq` is installed for basic hooks

**If hooks cause errors:**
- Check `logs/tool-data-errors.jsonl`
- Test scripts with sample JSON input
- Review script exit codes

Remember: This project demonstrates hook capabilities. Adapt the configurations and scripts to your specific needs.
</file>

<file path="README.md">
# Claude Code Hooks System

A comprehensive hooks infrastructure for Claude Code that provides automatic logging, security validation, and workflow automation.

## What Are Hooks?

Hooks are shell commands that run automatically at specific points in Claude Code's lifecycle. They receive JSON data via stdin and can control execution flow through exit codes.

```
Claude Code → Hook receives JSON → Your script runs → Exit code controls flow
```

## The 4 Hook Types

### 1. PreToolUse - Before any tool runs
**When:** Right before Claude executes a tool (Bash, Write, Edit, etc.)  
**Can:** Block execution, validate inputs, log attempts  
**Use Cases:**
- 🛡️ Block dangerous commands (`rm -rf /`)
- 📝 Log all commands before execution
- ✅ Validate file paths and permissions
- 🔍 Check branch before allowing file edits

**JSON Fields Available:**
```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../session.jsonl",  // JSONL file with full conversation history
  "tool_name": "Bash",
  "tool_input": {
    // Tool-specific fields (see examples below)
  }
}
```

### 2. PostToolUse - After tool completes
**When:** Right after a tool finishes (success or failure)  
**Can:** Process results, trigger actions, log outcomes  
**Use Cases:**
- 🎨 Auto-format code after file changes
- 📊 Log command results and exit codes
- 🔔 Alert on failures
- 🧪 Run tests after modifications

**JSON Fields Available:**
```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../session.jsonl",
  "tool_name": "Bash",
  "tool_input": {
    // Same as PreToolUse
  },
  "tool_response": {
    // Tool-specific response fields (see examples below)
  }
}
```

### 3. Notification - When Claude notifies you
**When:** Claude needs your attention or permission  
**Can:** Customize how you're notified  
**Use Cases:**
- 🔔 Desktop notifications
- 💬 Slack/Discord alerts
- 📱 Mobile push notifications
- 🔊 Sound alerts

**JSON Fields Available:**
```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../session.jsonl",
  "message": "Claude needs your input...",
  "title": "Claude Code"  // Optional
}
```

### 4. Stop - When Claude finishes responding
**When:** Claude completes its response  
**Can:** Summarize session, block stop if tasks incomplete  
**Use Cases:**
- 📈 Generate session analytics
- ✅ Check for uncommitted changes
- 📋 Create task summaries
- 🚫 Prevent stop if tests failing

**JSON Fields Available:**
```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../session.jsonl",
  "stop_hook_active": true
}
```

## How Hooks Work

### The Flow: Claude → Hook → Action

1. **You ask Claude to do something** (e.g., "run ls -la")
2. **Claude prepares to use a tool** (Bash in this case)
3. **Before execution:** PreToolUse hook fires
   - Claude pauses and sends JSON data to your hook
   - Your hook script receives the data via stdin
   - Hook can approve (exit 0) or block (exit 2)
4. **Tool executes** (if not blocked)
5. **After execution:** PostToolUse hook fires
   - Hook receives tool results
   - Can trigger follow-up actions
6. **Claude continues** with your request

### Hook Execution Example

When Claude wants to run `rm -rf /`:

```
1. Claude prepares: {"tool_name": "Bash", "tool_input": {"command": "rm -rf /"}}
   ↓
2. PreToolUse hook runs your validation script
   ↓
3. Script detects danger, exits with code 2
   ↓
4. Claude receives: "Dangerous command blocked!"
   ↓
5. Command is NOT executed, Claude tries alternative approach
```

### Exit Codes Matter
- **Exit 0**: "All good, proceed" 
- **Exit 2**: "Stop! Don't run this" (PreToolUse/Stop only)
- **Other**: "FYI there was an error" (but continue)

## Quick Start

### 1. Debug: Log Everything (see what data hooks receive)
```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": ".*",
      "hooks": [{
        "type": "command",
        "command": "cat >> ~/claude-hooks-debug.jsonl"
      }]
    }]
  }
}
```
This dumps the raw JSON for every tool call - perfect for exploring what data is available!

### 2. Basic Logging (jq)
```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Bash",
      "hooks": [{
        "type": "command",
        "command": "jq -r '.tool_input.command' >> commands.log"
      }]
    }]
  }
}
```

### 2. Security Validation (TypeScript)
```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Bash",
      "hooks": [{
        "type": "command",
        "command": "npx ts-node scripts/validate_bash.ts"
      }]
    }]
  }
}
```

### 3. Auto-formatting (Multiple tools)
```json
{
  "hooks": {
    "PostToolUse": [{
      "matcher": "Write|Edit|MultiEdit",
      "hooks": [{
        "type": "command",
        "command": "bash scripts/format_code.sh"
      }]
    }]
  }
}
```

## Data Available to Hooks

### All Hooks Get
- `session_id` - Unique session identifier
- `transcript_path` - Conversation log path

### PreToolUse Gets
- `tool_name` - Which tool is about to run
- `tool_input` - Tool-specific parameters

### PostToolUse Gets
- Everything from PreToolUse
- `tool_response` - Results, exit codes, output

### Tool Examples

**Bash:**
```json
{
  "tool_input": {
    "command": "ls -la",
    "description": "List files"
  },
  "tool_response": {
    "stdout": "file1.txt\nfile2.txt",
    "exit_code": 0
  }
}
```

**Write/Edit:**
```json
{
  "tool_input": {
    "file_path": "/path/to/file.py",
    "content": "print('hello')"  // Write only
  },
  "tool_response": {
    "success": true
  }
}
```

## Configuration

Hooks are configured in:
- `~/.claude/settings.json` - User settings (all projects)
- `.claude/settings.json` - Project settings
- `.claude/settings.local.json` - Local settings (git ignored)

### Matchers
- Exact: `"Bash"` - Only Bash tool
- Multiple: `"Write|Edit"` - Write OR Edit tools
- Pattern: `"Notebook.*"` - All Notebook tools
- All: `".*"` - Every tool

## This Repository

### Pre-built Scripts

| Script                     | Purpose                  | Hook Type       |
| -------------------------- | ------------------------ | --------------- |
| `validate_bash_command.ts` | Block dangerous commands | PreToolUse      |
| `log_tool_use.ts`          | Log all tool usage       | Pre/PostToolUse |
| `track_file_changes.ts`    | Audit file modifications | PreToolUse      |
| `format_code.sh`           | Run formatters           | PostToolUse     |
| `session_summary.ts`       | Generate analytics       | Stop            |

### Example Configurations

| File                               | Use Case                  |
| ---------------------------------- | ------------------------- |
| `examples/minimal-logging.json`    | Simple command logging    |
| `examples/security-focused.json`   | Maximum validation        |
| `examples/developer-workflow.json` | Auto-formatting & linting |

### Generated Logs

| Log File                   | Contains                  |
| -------------------------- | ------------------------- |
| `tool-usage.jsonl`         | Every tool call           |
| `bash-commands.log`        | All bash commands         |
| `file-changes-audit.jsonl` | File modification details |
| `session-summaries.txt`    | Session analytics         |

## Common Patterns

### Log Everything
```bash
# See what Claude is doing
tail -f logs/tool-data-summary.log
```

### Block Dangerous Operations
```typescript
if (file_path.includes("production")) {
    console.error("Cannot modify production files!");
    process.exit(2);
}
```

### Conditional Formatting
```bash
case "$FILE_EXT" in
  py) black "$FILE_PATH" ;;
  js|ts) prettier --write "$FILE_PATH" ;;
  go) gofmt -w "$FILE_PATH" ;;
esac
```

## Security Notes

⚠️ **Hooks run with YOUR permissions** - Review all hook scripts carefully!

- Always validate inputs
- Use absolute paths
- Quote shell variables
- Test in safe environment first
</file>

</files>
